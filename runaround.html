<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sokoban-like Game</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #222;
            color: #fff;
        }
        canvas {
            border: 1px solid #444;
            margin-bottom: 10px;
        }
        #messagePanel {
            width: 320px;
            height: 80px;
            background-color: #000;
            border: 1px solid #444;
            display: none;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
            image-rendering: pixelated;
        }
        #messageText {
            font-size: 16px;
            text-align: center;
            word-wrap: break-word;
        }
        #dismissButton {
            align-self: center;
            background-color: #444;
            border: none;
            color: #fff;
            padding: 5px 10px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
        #crystalCount {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="320" height="320"></canvas>
    <div id="messagePanel">
        <div id="messageText"></div>
        <button id="dismissButton">OK</button>
    </div>
    <div>Crystals: <span id="crystalCount">0</span></div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const tileSize = 32;
        
        let board = {
            tiles: [],
            player: { x: 0, y: 0 },
            crystals: 0,
            requiredCrystals: 3
        };
    
        function showMessage(message) {
            messageText.textContent = message;
            messagePanel.style.display = 'flex';
        }
    
        dismissButton.addEventListener('click', () => {
            messagePanel.style.display = 'none';
        });
    
        function loadLevel(levelData) {
            board.tiles = levelData.tiles;
            board.requiredCrystals = levelData.required_crystals;
            
            for (let y = 0; y < board.tiles.length; y++) {
                for (let x = 0; x < board.tiles[y].length; x++) {
                    if (board.tiles[y][x] === 'p') {
                        board.player.x = x;
                        board.player.y = y;
                        board.tiles[y][x] = '.';
                        return;
                    }
                }
            }
        }
    
        function getTileColor(tile) {
            const colorMap = {
                'w': 'brown',
                '.': 'lightgray',
                'c': 'lightgray',
                'x': board.crystals >= board.requiredCrystals ? 'green' : 'red',
                'm': 'lightgray',
                'h': 'lightgray',
                'ol': 'gray',
                'or': 'gray',
                'ou': 'gray',
                'od': 'gray'
            };
            return colorMap[tile] || 'white';
        }
    
        function getTileGlyph(tile) {
            const glyphMap = {
                'c': 'üíé',
                'x': board.crystals >= board.requiredCrystals ? 'üö™' : 'üîí',
                'm': 'üì¶',
                'h': 'üï≥Ô∏è',
                'ol': '‚Üê',
                'or': '‚Üí',
                'ou': '‚Üë',
                'od': '‚Üì'
            };
            return glyphMap[tile] || '';
        }
    
        function drawTile(x, y, tile) {
            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;
    
            ctx.fillStyle = getTileColor(tile);
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
    
            const glyph = getTileGlyph(tile);
            if (glyph) {
                ctx.fillStyle = 'black';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(glyph, centerX, centerY);
            }
        }
    
        function drawPlayer(x, y) {
            const playerX = x * tileSize + tileSize / 2;
            const playerY = y * tileSize + tileSize / 2;
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(playerX, playerY, tileSize / 5, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.strokeStyle = 'black';
            ctx.beginPath();
            ctx.moveTo(playerX, playerY + tileSize / 6);
            ctx.lineTo(playerX, playerY + tileSize / 2.5);
            ctx.moveTo(playerX - tileSize / 6, playerY + tileSize / 3);
            ctx.lineTo(playerX + tileSize / 6, playerY + tileSize / 3);
            ctx.moveTo(playerX, playerY + tileSize / 2.5);
            ctx.lineTo(playerX - tileSize / 6, playerY + tileSize / 1.8);
            ctx.moveTo(playerX, playerY + tileSize / 2.5);
            ctx.lineTo(playerX + tileSize / 6, playerY + tileSize / 1.8);
            ctx.stroke();
        }
    
        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let y = 0; y < board.tiles.length; y++) {
                for (let x = 0; x < board.tiles[y].length; x++) {
                    drawTile(x, y, board.tiles[y][x]);
                }
            }
            
            drawPlayer(board.player.x, board.player.y);
        }
    
        function updateCrystalCount() {
            document.getElementById('crystalCount').textContent = board.crystals;
        }
    
        function isValidMove(x, y) {
            return x >= 0 && x < board.tiles[0].length && y >= 0 && y < board.tiles.length;
        }
    
        function handleEmptyTile(newX, newY) {
            board.player.x = newX;
            board.player.y = newY;
        }
    
        function handleCrystalTile(newX, newY) {
            board.player.x = newX;
            board.player.y = newY;
            board.crystals++;
            board.tiles[newY][newX] = '.';
            updateCrystalCount();
        }
    
        function handleExitTile() {
            if (board.crystals >= board.requiredCrystals) {
                showMessage('Level Complete!');
                // Here you would load the next level
            }
        }
    
        function handleMovableTile(newX, newY, dx, dy) {
            const pushX = newX + dx;
            const pushY = newY + dy;
            if (board.tiles[pushY][pushX] === '.') {
                board.tiles[pushY][pushX] = 'm';
                board.tiles[newY][newX] = '.';
                board.player.x = newX;
                board.player.y = newY;
            } else if (board.tiles[pushY][pushX] === 'h') {
                board.tiles[pushY][pushX] = '.';
                board.tiles[newY][newX] = '.';
                board.player.x = newX;
                board.player.y = newY;
            }
        }
    
        function handleHoleTile() {
            showMessage('Game Over! You fell into a hole.');
            // Here you would reset the level
        }
    
        function handleOneWayTile(newX, newY, dx, dy) {
            const tileType = board.tiles[newY][newX];
            if ((tileType === 'ol' && dx === -1) ||
                (tileType === 'or' && dx === 1) ||
                (tileType === 'ou' && dy === -1) ||
                (tileType === 'od' && dy === 1)) {
                board.player.x = newX;
                board.player.y = newY;
            }
        }
    
        function movePlayer(dx, dy) {
            const newX = board.player.x + dx;
            const newY = board.player.y + dy;
            
            if (!isValidMove(newX, newY)) return;
            
            const targetTile = board.tiles[newY][newX];
            
            switch (targetTile) {
                case '.':
                    handleEmptyTile(newX, newY);
                    break;
                case 'c':
                    handleCrystalTile(newX, newY);
                    break;
                case 'x':
                    handleExitTile();
                    break;
                case 'm':
                    handleMovableTile(newX, newY, dx, dy);
                    break;
                case 'h':
                    handleHoleTile();
                    break;
                case 'ol':
                case 'or':
                case 'ou':
                case 'od':
                    handleOneWayTile(newX, newY, dx, dy);
                    break;
            }
            
            drawBoard();
        }
    
        document.addEventListener('keydown', (event) => {
            const moveMap = {
                'ArrowUp': [0, -1],
                'ArrowDown': [0, 1],
                'ArrowLeft': [-1, 0],
                'ArrowRight': [1, 0]
            };
            
            const [dx, dy] = moveMap[event.key] || [0, 0];
            if (dx !== 0 || dy !== 0) {
                movePlayer(dx, dy);
            }
        });
    
        // Sample level data (you would replace this with your full level data)
        const sampleLevel = {
            tiles: [
                ['w', 'w', 'w', 'w', 'w', 'w', 'w'],
                ['w', 'p', '.', '.', 'm', '.', 'w'],
                ['w', '.', 'ol', '.', 'or', '.', 'w'],
                ['w', 'c', 'ou', 'h', 'od', 'c', 'w'],
                ['w', '.', 'm', '.', 'm', '.', 'w'],
                ['w', 'c', '.', '.', '.', 'x', 'w'],
                ['w', 'w', 'w', 'w', 'w', 'w', 'w']
            ],
            required_crystals: 3
        };
    
        loadLevel(sampleLevel);
        drawBoard();
        updateCrystalCount();
    </script>
</body>
</html>
